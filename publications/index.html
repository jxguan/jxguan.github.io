<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Publications | Jiaxin Guan </title> <meta name="author" content="Jiaxin Guan"> <meta name="description" content="A complete list of my publications in reversed chronological order."> <meta name="keywords" content="cryptography, bounded-storage-model, theoretical-computer-science, jiaxin-guan, information-theoretic-cryptography"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?83afd31ed94045a6a331b2f941b0975e"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://www.guan.io/publications/"> <script src="/assets/js/theme.js?2a4bb780e46666681daa27a167a34e26"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Jiaxin Guan | <span class="chinese-text">管佳鑫</span> </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/publications/">Publications <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Publications</h1> <p class="post-description">"There is a limit to our life, but to knowledge there is no limit." - <i> Zhuangzi </i> <br> <span class="chinese-text">吾生也有涯，而知也无涯。 - <i>庄子</i></span> </p> </header> <article> <div class="publications"> <h2 class="bibliography">2024</h2> <ol class="bibliography"> <li> <div class="row"> <div id="DGKS24b" class="col-sm-10"> <div class="title">(Multi-Input) FE for Randomized Functionalities, Revisited</div> <div class="author"> <a href="https://scholar.google.com/citations?user=pUozQ_wAAAAJ" rel="external nofollow noopener" target="_blank">Pratish Datta</a>, Jiaxin Guan, <a href="https://dblp.org/pid/272/2390.html" rel="external nofollow noopener" target="_blank">Alexis Korb</a>, and <a href="https://web.cs.ucla.edu/~sahai/" rel="external nofollow noopener" target="_blank">Amit Sahai</a> </div> <div class="periodical"> </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>Randomized functional encryption (rFE) generalizes functional encryption (FE) by incorporating randomized functionalities. Randomized multi-input functional encryption (rMIFE) extends rFE to accommodate multi-input randomized functionalities. <br> <br> In this paper, we reassess the framework of rFE/rMIFE enhancing our understanding of this primitive and laying the groundwork for more secure and flexible constructions in this field. Specifically, we make three key contributions:</p> <ul> <li> <b>New definition:</b> We identify critical gap in the existing indistinguishability-based (IND) security definition for rFE/rMIFE. Notably, current definition fails to adequately address security against malicious encryptors—a crucial requirement for rFE/rMIFE since their introduction. We propose a novel, robust IND security definition that not only addresses threats from malicious decryptors but also quantifies the security against malicious encryptors effectively. </li> <li> <b>Counterexample:</b> To illustrate the importance of this definitional gap, we provide a counterexample of an insecure rFE scheme that meets IND security under the previous definition but explicitly fails in a natural setting (and where this failure would be precluded by our enhanced definition). Our counterexample scheme is non-trivial and meticulously designed using standard cryptographic tools, namely FE for deterministic functions, pseudorandom function (PRF), public key encryption (PKE), and simulation-sound non-interactive zero-knowledge (NIZK) proof systems. </li> <li> <b>Adaptive unbounded-message secure construction:</b> The only viable prior construction of rMIFE by Goldwasser et al. [EUROCRYPT 2014] (which uses indistinguishability obfuscation (iO) and other standard assumptions) has significant limitations: it permits only a pre-defined number of messages per encryption slot and operates under selective-security constraints, requiring adversaries to declare challenge ciphertext queries and "corrupted" encryption keys in advance. We address these shortcomings by employing sub-exponentially secure iO. Technically, we build on and adapt methods developed by Goyal et al.[ASIACRYPT 2016] for deterministic MIFE. </li> </ul> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@article</span><span class="p">{</span><span class="nl">DGKS24b</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{(Multi-Input) FE for Randomized Functionalities, Revisited}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Datta, Pratish and Guan, Jiaxin and Korb, Alexis and Sahai, Amit}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2024}</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> <li> <div class="row"> <div id="DGHL24" class="col-sm-10"> <div class="title">HELP: Everlasting Privacy through Server-Aided Randomness</div> <div class="author"> <a href="https://cs.nyu.edu/~dodis/" rel="external nofollow noopener" target="_blank">Yevgeniy Dodis</a>, Jiaxin Guan, Peter Hall, and Alison Lin </div> <div class="periodical"> <em>In <b> IACR CiC </b> </em> , 2024 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>Everlasting (EL) privacy offers an attractive solution to the Store-Now-Decrypt-Later (SNDL) problem, where future increases in the attacker’s capability could break systems which are believed to be secure today. Instead of requiring full information-theoretic security, everlasting privacy allows computationally-secure transmissions of ephemeral secrets, which are only "effective" for a limited periods of time, after which their compromise is provably useless for the SNDL attacker. <br> <br> In this work we revisit such everlasting privacy model of Dodis and Yeo (ITC’21), which we call Hypervisor EverLasting Privacy (HELP). HELP is a novel architecture for generating shared randomness using a network of semi-trusted servers (or "hypervisors"), trading the need to store/distribute large shared secrets with the assumptions that it is hard to: (a) simultaneously compromise too many publicly accessible ad-hoc servers; and (b) break a computationally-secure encryption scheme very quickly. While Dodis and Yeo presented good HELP solutions in the asymptotic sense, their solutions were concretely expensive and used heavy tools (like large finite fields or gigantic Toeplitz matrices). <br> <br> We abstract and generalize the HELP architecture to allow for more efficient instantiations, and construct several concretely efficient HELP solutions. Our solutions use elementary cryptographic operations, such as hashing and message authentication. We also prove a very strong composition theorem showing that our EL architecture can use any message transmission method which is computationally-secure in the Universal Composability (UC) framework. This is the first positive composition result for everlasting privacy, which was otherwise known to suffer from many "non-composition" results (Müller-Quade and Unruh; J of Cryptology’10).</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@article</span><span class="p">{</span><span class="nl">DGHL24</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{HELP: Everlasting Privacy through Server-Aided Randomness}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Dodis, Yevgeniy and Guan, Jiaxin and Hall, Peter and Lin, Alison}</span><span class="p">,</span>
  <span class="na">journal</span> <span class="p">=</span> <span class="s">{{IACR} {C}ommunications in {C}ryptology}</span><span class="p">,</span>
  <span class="na">publisher</span> <span class="p">=</span> <span class="s">{{I}nternational {A}ssociation for {C}ryptologic {R}esearch}</span><span class="p">,</span>
  <span class="na">volume</span> <span class="p">=</span> <span class="s">{1}</span><span class="p">,</span>
  <span class="na">number</span> <span class="p">=</span> <span class="s">{3}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2024}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> <li> <div class="row"> <div id="EPRINT:DGKS24a" class="col-sm-10"> <div class="title">Adaptively Secure Streaming Functional Encryption</div> <div class="author"> <a href="https://scholar.google.com/citations?user=pUozQ_wAAAAJ" rel="external nofollow noopener" target="_blank">Pratish Datta</a>, Jiaxin Guan, <a href="https://dblp.org/pid/272/2390.html" rel="external nofollow noopener" target="_blank">Alexis Korb</a>, and <a href="https://web.cs.ucla.edu/~sahai/" rel="external nofollow noopener" target="_blank">Amit Sahai</a> </div> <div class="periodical"> </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2024/355.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>This paper introduces the first adaptively secure streaming functional encryption (sFE) scheme for P/Poly. sFE stands as an evolved variant of traditional functional encryption (FE), catering specifically to contexts with vast and/or dynamically evolving data sets. sFE is designed for applications where data arrives in a streaming fashion and is computed on in an iterative manner as the stream arrives. Unlike standard FE, in sFE: (1) encryption is possible without knowledge of the full data set, (2) partial decryption is possible given only a prefix of the input. <br> <br> Guan, Korb, and Sahai introduced this concept in their recent publication [CRYPTO 2023], where they constructed an sFE scheme for P/Poly using a compact standard FE scheme for the same. However, their sFE scheme only achieved semi-adaptive-function-selective security, which constrains the adversary to obtain all functional keys prior to seeing any ciphertext for the challenge stream. This limitation severely limits the scenarios where sFE can be applied, and therefore fails to provide a suitable theoretical basis for sFE. <br> <br> In contrast, the adaptive security model empowers the adversary to arbitrarily interleave requests for functional keys with ciphertexts related to the challenge stream. Guan, Korb, and Sahai identified achieving adaptive security for sFE as the key question left open by their work. <br> <br> We resolve this open question positively by constructing an adaptively secure sFE construction from indistinguishability obfuscation for P/Poly and injective PRGs. By combining our work with that of Jain, Lin, and Sahai [STOC 2021, EUROCRYPT 2022], we obtain the first adaptively secure sFE scheme for P/Poly based on sub-exponential hardness of well-studied computational problems.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@article</span><span class="p">{</span><span class="nl">EPRINT:DGKS24a</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Adaptively Secure Streaming Functional Encryption}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Datta, Pratish and Guan, Jiaxin and Korb, Alexis and Sahai, Amit}</span><span class="p">,</span>
  <span class="na">journal</span> <span class="p">=</span> <span class="s">{Cryptology ePrint Archive}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2024}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> <li> <div class="row"> <div id="C:GuaMon24" class="col-sm-10"> <div class="title">On Sequential Functions and Fine-Grained Cryptography</div> <div class="author"> Jiaxin Guan, and <a href="https://scholar.google.com/citations?user=ePPyg5MAAAAJ" rel="external nofollow noopener" target="_blank">Hart Montgomery</a> </div> <div class="periodical"> <em>In <b> CRYPTO </b> </em> , 2024 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2024/1050.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>A sequential function is, informally speaking, a function f for which a massively parallel adversary cannot compute "substantially" faster than an honest user with limited parallel computation power. Sequential functions form the backbone of many primitives that are extensively used in blockchains such as verifiable delay functions (VDFs) and time-lock puzzles. Despite this widespread practical use, there has been little work studying the complexity or theory of sequential functions. <br><br> Our main result is a black-box oracle separation between sequential functions and one-way functions: in particular, we show the existence of an oracle O that implies a sequential function but not a one-way function. This seems surprising since sequential functions are typically constructed from very strong assumptions that imply one-way functions and also since time-lock puzzles are known to imply one-way functions (Bitansky et al., ITCS ’16). <br><br> We continue our exploration of the theory of sequential functions. We show that, informally speaking, the decisional, worst-case variant of a certain class of sequential function called a continuous iterative sequential function (CISF) is PSPACE-complete. A CISF is, in a nutshell, a sequential function f that can be written in the form f(k, x) = g<sup>k</sup>(x) for some function g where k is an input determining the number of "rounds" the function is evaluated. We then show that more general forms of sequential functions are not contained in PSPACE relative to a random oracle. <br><br> Given these results, we then ask if it is possible to build any interesting cryptographic primitives from sequential functions that are not one-way. It turns out that even if we assume just the existence of a CISF that is not one-way, we can build certain "fine-grained" cryptographic primitives where security is defined similarly to traditional primitives with the exception that it is only guaranteed for some (generally polynomial) amount of time. In particular, we show how to build "fine-grained" symmetric key encryption and "fine-grained" MACs from a CISF. We also show how to build fine-grained public-key encryption from a VDF with a few extra natural properties and indistinguishability obfucsation (iO) for null circuits. We do not assume one-way functions. Finally, we define a primitive that we call a commutative sequential function–essentially a sequential function that can be computed in sequence to get the same output in two different ways–and show that it implies fine-grained key exchange.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">C:GuaMon24</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{On Sequential Functions and Fine-Grained Cryptography}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin and Montgomery, Hart}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Annual International Cryptology Conference}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{393--428}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2024}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> </ol> <h2 class="bibliography">2023</h2> <ol class="bibliography"> <li> <div class="row"> <div id="TCC:GuaWicZha23" class="col-sm-10"> <div class="title">Multi-Instance Randomness Extraction and Security against Bounded-Storage Mass Surveillance</div> <div class="author"> Jiaxin Guan, <a href="https://www.khoury.northeastern.edu/home/wichs/" rel="external nofollow noopener" target="_blank">Daniel Wichs</a>, and <a href="https://mzhandry.github.io/" rel="external nofollow noopener" target="_blank">Mark Zhandry</a> </div> <div class="periodical"> <em>In <b> TCC </b> </em> , 2023 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2023/409.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>Consider a state-level adversary who observes and stores large amounts of encrypted data from all users on the Internet, but does not have the capacity to store it all. Later, it may target certain "persons of interest" in order to obtain their decryption keys. We would like to guarantee that, if the adversary‘s storage capacity is only (say) 1% of the total encrypted data size, then even if it can later obtain the decryption keys of arbitrary users, it can only learn something about the contents of (roughly) 1% of the ciphertexts, while the rest will maintain full security. This can be seen as an extension of <i>incompressible cryptography</i> (Dziembowski CRYPTO ’06, Guan, Wichs and Zhandry EUROCRYPT ’22) to the <i>multi-user</i> setting. We provide solutions in both the symmetric key and public key setting with various trade-offs in terms of computational assumptions and efficiency. <br><br>As the core technical tool, we study an information-theoretic problem which we refer to as "multi-instance randomness extraction." Suppose X<sub>1</sub>, ..., X<sub>t</sub> are correlated random variables whose total joint min-entropy rate is α, but we know nothing else about their individual entropies. We choose t$ random and independent seeds S<sub>1</sub>, ..., S<sub>t</sub> and attempt to individually extract some small amount of randomness Y<sub>i</sub> = Ext(X<sub>i</sub>; S<sub>i</sub>) from each X<sub>i</sub>. We’d like to say that roughly an α-fraction of the extracted outputs Y<sub>i</sub> should be indistinguishable from uniform even given all the remaining extracted outputs and all the seeds. We show that this indeed holds for specific extractors based on Hadamard and Reed-Muller codes.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">TCC:GuaWicZha23</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Multi-Instance Randomness Extraction and Security against Bounded-Storage Mass Surveillance}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin and Wichs, Daniel and Zhandry, Mark}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Theory of Cryptography Conference}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{93--122}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2023}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> <li> <div class="row"> <div id="C:GuaKorSah23" class="col-sm-10"> <div class="title">Streaming Functional Encryption</div> <div class="author"> Jiaxin Guan, <a href="https://dblp.org/pid/272/2390.html" rel="external nofollow noopener" target="_blank">Alexis Korb</a>, and <a href="https://web.cs.ucla.edu/~sahai/" rel="external nofollow noopener" target="_blank">Amit Sahai</a> </div> <div class="periodical"> <em>In <b> CRYPTO </b> </em> , 2023 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2022/1599.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>We initiate the study of streaming functional encryption (sFE) which is designed for scenarios in which data arrives in a streaming manner and is computed on in an iterative manner as the stream arrives. Unlike in a standard functional encryption (FE) scheme, in an sFE scheme, we (1) do not require the entire data set to be known at encryption time and (2) allow for partial decryption given only a prefix of the input. More specifically, in an sFE scheme, we can sequentially encrypt each data point x<sub>i</sub> in a stream of data x = x<sub>1</sub>...x<sub>n</sub> as it arrives, without needing to wait for all n values. We can then generate function keys for streaming functions which are stateful functions that take as input a message x<sub>i</sub> and a state st<sub>i</sub> and output a value y<sub>i</sub> and the next state st<sub>i+1</sub>. For any k ≤ n, a user with a function key for a streaming function f can learn the first k output values y<sub>1</sub>...y<sub>k</sub> where (y<sub>i</sub>, st<sub>i+1</sub>) = f(x<sub>i</sub>, st<sub>i</sub>) and st<sub>1</sub> = ⟂ given only ciphertexts for the first k elements x<sub>1</sub>...x<sub>k</sub>. <br><br> In this work, we introduce the notion of sFE and show how to construct it from FE. In particular, we show how to achieve a secure sFE scheme for P/Poly from a compact, secure FE scheme for P/Poly, where our security notion for sFE is similar to standard FE security except that we require all function queries to be made before the challenge ciphertext query. Furthermore, by combining our result with the FE construction of Jain, Lin, and Sahai (STOC, 2022), we show how to achieve a secure sFE scheme for P/Poly from the polynomial hardness of well-studied assumptions.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">C:GuaKorSah23</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Streaming Functional Encryption}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin and Korb, Alexis and Sahai, Amit}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Annual International Cryptology Conference}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{433--463}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2023}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> <li> <div class="row"> <div id="guan2023cryptography" class="col-sm-10"> <div class="title">Cryptography against Space-Bounded Adversaries</div> <div class="author"> Jiaxin Guan </div> <div class="periodical"> <em>Ph.D. Dissertation</em> </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="/assets/pdf/dissertation.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>Traditionally in cryptography, we consider adversaries that are time-bounded by making certain computational assumptions. In this thesis, I study the scenario where the adversaries are space-bounded, i.e. the adversary can only use up to a certain amount of memory bits. Under these scenarios, we can achieve either unconditional security properties or neverbefore-possible results. <br> <br> First, I start off with Maurer’s Bounded Storage Model. It is a model where the adversary abides by a certain memory bound throughout the entire attack. Under this model, I show simple constructions of a key-agreement protocol, a commitment scheme, and an oblivious transfer protocol, all based on Raz’s lower bound on parity learning. These constructions have several advantages over prior work, including enhanced correctness and an improved and optimal number of rounds. <br> <br> Subsequently, I show that if we combine computational assumptions with the bounded storage model, we can achieve results that are not possible in the standard model. I define a new object named Online Obfuscation, which is analogous to a Virtual Grey-Box Obfuscation in the Bounded Storage Model, and show how to use it to construct disappearing encryption and signature schemes where the ciphertext and the signature effectively "disappear" after transmission. <br> <br> Lastly, I make the observation that in the Bounded Storage Model, the memory bound on the adversary is enforced throughout the entire game. One can imagine a variant where the bound is only enforced for long-term storage, allowing the adversary to use an arbitrary amount of memory during the transmission phase. I define incompressible cryptography to capture this intuition and show constructions using randomness extractors and other cryptographic tools. Furthermore, I show that under the multi-user setting, we can still achieve desired incompressible security if we simply replace the randomness extractor with a special "multi-instance randomness extractor".</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@phdthesis</span><span class="p">{</span><span class="nl">guan2023cryptography</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Cryptography against Space-Bounded Adversaries}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2023}</span><span class="p">,</span>
  <span class="na">school</span> <span class="p">=</span> <span class="s">{Princeton University}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> <li> <div class="row"> <div id="EC:BonGuaZha23" class="col-sm-10"> <div class="title">A Lower Bound on the Length of Signatures Based on Group Actions and Generic Isogenies</div> <div class="author"> <a href="https://crypto.stanford.edu/~dabo/" rel="external nofollow noopener" target="_blank">Dan Boneh</a>, Jiaxin Guan, and <a href="https://mzhandry.github.io/" rel="external nofollow noopener" target="_blank">Mark Zhandry</a> </div> <div class="periodical"> <em>In <b> EUROCRYPT </b> </em> , 2023 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2023/250.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>We give the first black box lower bound for isogeny-based protocols that can be described as group actions. We show that, for a large class of signature schemes making black box use of a (potentially non-abelian) group action, the signature length must be Ω(λ<sup>2</sup>/log λ). Our class of signatures generalizes all known signatures that derive security exclusively from the group action, and our lower bound matches the state of the art, showing that the signature length cannot be improved without deviating from the group action framework.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">EC:BonGuaZha23</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{A Lower Bound on the Length of Signatures Based on Group Actions and Generic Isogenies}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Boneh, Dan and Guan, Jiaxin and Zhandry, Mark}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Annual International Conference on the Theory and Applications of Cryptographic Techniques}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{507--531}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2023}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> </ol> <h2 class="bibliography">2022</h2> <ol class="bibliography"><li> <div class="row"> <div id="EC:GuaWicZha22" class="col-sm-10"> <div class="title">Incompressible Cryptography</div> <div class="author"> Jiaxin Guan, <a href="https://www.khoury.northeastern.edu/home/wichs/" rel="external nofollow noopener" target="_blank">Daniel Wichs</a>, and <a href="https://mzhandry.github.io/" rel="external nofollow noopener" target="_blank">Mark Zhandry</a> </div> <div class="periodical"> <em>In <b> EUROCRYPT </b> </em> , 2022 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2021/1679.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>Incompressible encryption allows us to make the ciphertext size flexibly large and ensures that an adversary learns nothing about the encrypted data, even if the decryption key later leaks, unless she stores essentially the entire ciphertext. Incompressible signatures can be made arbitrarily large and ensure that an adversary cannot produce a signature on any message, even one she has seen signed before, unless she stores one of the signatures essentially in its entirety.<br><br>In this work, we give simple constructions of both incompressible public-key encryption and signatures under minimal assumptions. Furthermore, large incompressible ciphertexts (resp. signatures) can be decrypted (resp. verified) in a streaming manner with low storage. In particular, these notions strengthen the related concepts of disappearing encryption and signatures, recently introduced by Guan and Zhandry (TCC 2021), whose previous constructions relied on sophisticated techniques and strong, non-standard assumptions. We extend our constructions to achieve an optimal "rate", meaning the large ciphertexts (resp. signatures) can contain almost equally large messages, at the cost of stronger assumptions.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">EC:GuaWicZha22</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Incompressible Cryptography}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin and Wichs, Daniel and Zhandry, Mark}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Annual International Conference on the Theory and Applications of Cryptographic Techniques}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{700--730}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2022}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li></ol> <h2 class="bibliography">2021</h2> <ol class="bibliography"> <li> <div class="row"> <div id="TCC:GuaZha21" class="col-sm-10"> <div class="title">Disappearing Cryptography in the Bounded Storage Model</div> <div class="author"> Jiaxin Guan, and <a href="https://mzhandry.github.io/" rel="external nofollow noopener" target="_blank">Mark Zhandry</a> </div> <div class="periodical"> <em>In <b> TCC </b> </em> , 2021 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2021/406.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>In this work, we study disappearing cryptography in the bounded storage model. Here, a component of the transmission, say a ciphertext, a digital signature, or even a program, is streamed bit by bit. The stream is so large for anyone to store in its entirety, meaning the transmission effectively disappears once the stream stops.<br><br>We first propose the notion of online obfuscation, capturing the goal of disappearing programs in the bounded storage model. We give a negative result for VBB security in this model, but propose candidate constructions for a weaker security goal, namely VGB security. We then demonstrate the utility of VGB online obfuscation, showing that it can be used to generate disappearing ciphertexts and signatures. All of our applications are <i>not</i> possible in the standard model of cryptography, regardless of computational assumptions used.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">TCC:GuaZha21</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Disappearing Cryptography in the Bounded Storage Model}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin and Zhandry, Mark}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Theory of Cryptography: 19th International Conference, TCC 2021, Raleigh, NC, USA, November 8--11, 2021, Proceedings, Part II 19}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{365--396}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2021}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> <li> <div class="row"> <div id="EPRINT:GuaZha21b" class="col-sm-10"> <div class="title">Iterated Inhomogeneous Polynomials</div> <div class="author"> Jiaxin Guan, and <a href="https://mzhandry.github.io/" rel="external nofollow noopener" target="_blank">Mark Zhandry</a> </div> <div class="periodical"> <em>In <b> CFail </b> </em> , 2021 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2021/1399.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>Let p be a polynomial, and let p<sup>(i)</sup>(x) be the result of iterating the polynomial i times, starting at an input x. The case where p(x) is the homogeneous polynomial x<sup>2</sup> has been extensively studied in cryptography. Due to its associated group structure, iterating this polynomial gives rise to a number of interesting cryptographic applications such as time-lock puzzles and verifiable delay functions. On the other hand, the associated group structure leads to quantum attacks on the applications.<br><br>In this work, we consider whether <i>inhomogeneous</i> polynomials, such as 2x<sup>2</sup>+3x+1, can have useful cryptographic applications. We focus on the case of polynomials mod 2<sup>n</sup>, due to some useful mathematical properties. The natural group structure no longer exists, so the quantum attacks but also applications no longer immediately apply. We nevertheless show classical polynomial-time attacks on analogs of hard problems from the homogeneous setting. We conclude by proposing new computational assumptions relating to these inhomogeneous polynomials, with cryptographic applications.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@article</span><span class="p">{</span><span class="nl">EPRINT:GuaZha21b</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Iterated Inhomogeneous Polynomials}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin and Zhandry, Mark}</span><span class="p">,</span>
  <span class="na">journal</span> <span class="p">=</span> <span class="s">{Cryptology ePrint Archive}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2021}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li> </ol> <h2 class="bibliography">2019</h2> <ol class="bibliography"><li> <div class="row"> <div id="EC:GuaZha19" class="col-sm-10"> <div class="title">Simple Schemes in the Bounded Storage Model</div> <div class="author"> Jiaxin Guan, and <a href="https://mzhandry.github.io/" rel="external nofollow noopener" target="_blank">Mark Zhandry</a> </div> <div class="periodical"> <em>In <b> EUROCRYPT </b> </em> , 2019 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2019/507.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>The bounded storage model promises unconditional security proofs against computationally unbounded adversaries, so long as the adversary’s space is bounded. In this work, we develop simple new constructions of two-party key agreement, bit commitment, and oblivious transfer in this model. In addition to simplicity, our constructions have several advantages over prior work, including an improved number of rounds and enhanced correctness. Our schemes are based on Raz’s lower bound for learning parities.</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">EC:GuaZha19</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Simple Schemes in the Bounded Storage Model}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Guan, Jiaxin and Zhandry, Mark}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Advances in Cryptology--EUROCRYPT 2019: 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Darmstadt, Germany, May 19--23, 2019, Proceedings, Part III 38}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{500--524}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2019}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li></ol> <h2 class="bibliography">2018</h2> <ol class="bibliography"><li> <div class="row"> <div id="TCC:BGMZ18" class="col-sm-10"> <div class="title">Return of GGH15: Provable Security against Zeroizing Attacks</div> <div class="author"> <a href="https://sites.google.com/view/jamesbartusek" rel="external nofollow noopener" target="_blank">James Bartusek</a>, Jiaxin Guan, <a href="https://fermima.com/" rel="external nofollow noopener" target="_blank">Fermi Ma</a>, and <a href="https://mzhandry.github.io/" rel="external nofollow noopener" target="_blank">Mark Zhandry</a> </div> <div class="periodical"> <em>In <b> TCC </b> </em> , 2018 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://eprint.iacr.org/2018/511.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">ePrint</a> <a class="bibtex btn btn-sm z-depth-0" role="button">Bib</a> </div> <div class="abstract hidden"> <p>The GGH15 multilinear maps have served as the foundation for a number of cutting-edge cryptographic proposals. Unfortunately, many schemes built on GGH15 have been explicitly broken by so-called "zeroizing attacks", which exploit leakage from honest zero-test queries. The precise settings in which zeroizing attacks are possible have remained unclear. Most notably, none of the current indistinguishability obfuscation (iO) candidates from GGH15 have any formal security guarantees against zeroizing attacks.<br><br>In this work, we demonstrate that all known zeroizing attacks on GGH15 implicitly construct algebraic relations between the results of zero-testing and the encoded plaintext elements. We then propose a "GGH15 zeroizing model" as a new general framework which greatly generalizes known attacks.<br><br>Our second contribution is to describe a new GGH15 variant, which we formally analyze in our GGH15 zeroizing model. We then construct a new iO candidate using our multilinear map, which we prove secure in the GGH15 zeroizing model. This implies resistance to all known zeroizing strategies. The proof relies on the Branching Program Un-Annihilatability (BPUA) Assumption of Garg et al. [TCC 16-B] (which is implied by PRFs in NC<sup>1</sup> secure against P/Poly) and the complexity-theoretic p-Bounded Speedup Hypothesis of Miles et al. [ePrint 14] (a strengthening of the Exponential Time Hypothesis).</p> </div> <div class="bibtex hidden"> <figure class="highlight"><pre><code class="language-bibtex" data-lang="bibtex"><span class="nc">@inproceedings</span><span class="p">{</span><span class="nl">TCC:BGMZ18</span><span class="p">,</span>
  <span class="na">title</span> <span class="p">=</span> <span class="s">{Return of GGH15: Provable Security against Zeroizing Attacks}</span><span class="p">,</span>
  <span class="na">author</span> <span class="p">=</span> <span class="s">{Bartusek, James and Guan, Jiaxin and Ma, Fermi and Zhandry, Mark}</span><span class="p">,</span>
  <span class="na">booktitle</span> <span class="p">=</span> <span class="s">{Theory of Cryptography Conference}</span><span class="p">,</span>
  <span class="na">pages</span> <span class="p">=</span> <span class="s">{544--574}</span><span class="p">,</span>
  <span class="na">year</span> <span class="p">=</span> <span class="s">{2018}</span><span class="p">,</span>
  <span class="na">organization</span> <span class="p">=</span> <span class="s">{Springer}</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure> </div> </div> </div> </li></ol> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Jiaxin Guan. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: December 11, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?40570e5b3690df808c39da71f6dee543"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-H78Z01D5D0"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-H78Z01D5D0");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>